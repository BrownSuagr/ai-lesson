### 学习目标

* 知道注意力机制的工作流程
* 理解三个阶段过程

## 1 注意力机制原理

### 1.1 注意力机制示意图

Attention机制的工作原理并不复杂，我们可以用下面这张图做一个总结

  ![img](img/331.png)

### 1.2 Attention计算过程

* 阶段一: query 和 key 进行相似度计算，得到一个query 和 key 相关性的分值
* 阶段二: 将这个分值进行归一化(softmax)，得到一个注意力的分布
* 阶段三: 使用注意力分布和 value 进行计算，得到一个融合注意力的更好的 value 值

为了更好的说明上面的情况, 我们通过注意力来做一个机器翻译(NMT) 的任务，机器翻译中，我们会使用 seq2seq 的架构，每个时间步从词典里生成一个翻译的结果。就像下面这张图一样.

![img](img/332.png)

在没有注意力之前，我们每次都是根据 Encoder 部分的输出结果来进行生成，提出注意力后，就是想在生成翻译结果时并不是看 Encoder 中所有的输出结果，而是先来看看想生成的这部分和哪些单词可能关系会比较大，关系大的我多借鉴些；关系小的，少借鉴些。就是这样一个想法，我们看看该如何操作。

- 这里为了生成单词，我们把 Decoder 部分输入后得到的向量作为 query；把 Encoder 部分每个单词的向量作为 key。首先我们先把 query 和 每一个单词进行点乘$score=query\cdot key$，得到相关性的分值；
- 有了这些分值后，我们对这些分值做一个$softmax$ ，得到一个注意力的分布
- 有了这个注意力，我们就可以用它和 Encoder 的输出值 (value) 进行相乘，得到一个加权求和后的值，这个值就包含注意力的表示，我们用它来预测要生成的词。

这个过程我们可以看看一个动图的事例理解一下:

<center><video height="300px" width="520px" id="video" controls="" preload="none" poster="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1579034948975&di=1661e09f4b226dd5d1089f89bec55c25&imgtype=0&src=http%3A%2F%2F01imgmini.eastday.com%2Fmobile%2F20190321%2F20190321201641_9c06629147dde97d8234d1a012e8beee_3.jpeg">
<source id="mp4" src="./img/3.mp4" type="video/mp4">
</video></center>

### 1.3 Attention计算逻辑

当然，Attention 并不是只有这一种计算方式，后来还有很多人找到了各种各样的计算注意力的方法, 比如我们上面介绍的三种计算规则, 但是从本质上，它们都遵循着这个三步走的逻辑:

- query 和 key 进行相似度计算，得到一个query 和 key 相关性的分值
- 将这个分值进行归一化(softmax)，得到一个注意力的分布
- 使用注意力分布和 value 进行计算，得到一个融合注意力的更好的 value 值

### 1.4 有无attention模型对比

#### 1 无attention机制的模型

![img](img/337.png)

- 文本处理领域的Encoder-Decoder框架可以这么直观地去理解：可以把它看作适合处理由一个句子（或篇章）生成另外一个句子（或篇章）的通用处理模型。对于句子对<Source,Target>，我们的目标是给定输入句子Source，期待通过Encoder-Decoder框架来生成目标句子Target。Source和Target可以是同一种语言，也可以是两种不同的语言。而Source和Target分别由各自的单词序列构成：
  $$
  Source = \langle X_1,X_2 \cdots X_m \rangle \\\\
  Target = \langle y_1,y_2 \cdots y_n \rangle
  $$

- encoder顾名思义就是对输入句子Source进行编码，将输入句子通过非线性变换转化为中间语义表示C：
  $$
  C = F(X_1,X_2 \cdots X_m)
  $$

- 对于解码器Decoder来说，其任务是根据句子Source的中间语义表示C和之前已经生成的历史信息,y_1, y_2…y_i-1来生成i时刻要生成的单词y_i
  $$
  y_i = G(C,y_1,y_2 \cdots y_{i-1})
  $$

- 上述图中展示的Encoder-Decoder框架是没有体现出“注意力模型”的，所以可以把它看作是注意力不集中的分心模型。为什么说它注意力不集中呢？请观察下目标句子Target中每个单词的生成过程如下：
  $$
  y_1 = f(C) \\\\
  y_2 = f(C, y_1) \\\\
  y_3 = f(C, y_1, y_2)
  $$

- 其中f是Decoder的非线性变换函数。从这里可以看出，在生成目标句子的单词时，不论生成哪个单词，它们使用的输入句子Source的语义编码C都是一样的，没有任何区别。

- 每个yi都依次这么产生，那么看起来就是整个系统根据输入句子Source生成了目标句子Target。如果Source是中文句子，Target是英文句子，那么这就是解决机器翻译问题的Encoder-Decoder框架；如果Source是一篇文章，Target是概括性的几句描述语句，那么这是文本摘要的Encoder-Decoder框架；如果Source是一句问句，Target是一句回答，那么这是问答系统或者对话机器人的Encoder-Decoder框架。由此可见，在文本处理领域，Encoder-Decoder的应用领域相当广泛。

- **问题点是**: 语义编码C是由句子Source的每个单词经过Encoder 编码产生的，这意味着不论是生成哪个单词，还是，其实句子Source中任意单词对生成某个目标单词yi来说影响力都是相同的，这是为何说这个模型没有体现出注意力的缘由。这类似于人类看到眼前的画面，但是眼中却没有注意焦点一样.

#### 2 有attention机制的模型

- 如果拿机器翻译来解释这个分心模型的Encoder-Decoder框架更好理解，比如输入的是英文句子：Tom chase Jerry，Encoder-Decoder框架逐步生成中文单词：“汤姆”，“追逐”，“杰瑞”。在翻译“杰瑞”这个中文单词的时候，分心模型里面的每个英文单词对于翻译目标单词“杰瑞”贡献是相同的，很明显这里不太合理，显然“Jerry”对于翻译成“杰瑞”更重要，但是分心模型是无法体现这一点的，这就是为何说它没有引入注意力的原因。

- 没有引入注意力的模型在输入句子比较短的时候问题不大，但是如果输入句子比较长，此时所有语义完全通过一个中间语义向量来表示，单词自身的信息已经消失，可想而知会丢失很多细节信息，这也是为何要引入注意力模型的重要原因。

- 上面的例子中，如果引入Attention模型的话，应该在翻译“杰瑞”的时候，体现出英文单词对于翻译当前中文单词不同的影响程度，比如给出类似下面一个概率分布值：（Tom,0.3）(Chase,0.2) (Jerry,0.5).每个英文单词的概率代表了翻译当前单词“杰瑞”时，注意力分配模型分配给不同英文单词的注意力大小。这对于正确翻译目标语单词肯定是有帮助的，因为引入了新的信息。

- 同理，目标句子中的每个单词都应该学会其对应的源语句子中单词的注意力分配概率信息。这意味着在生成每个单词的时候，原先都是相同的中间语义表示C会被替换成根据当前生成单词而不断变化的。理解Attention模型的关键就是这里，即由固定的中间语义表示C换成了根据当前输出单词来调整成加入注意力模型的变化的。增加了注意力模型的Encoder-Decoder框架理解起来如下图所示:

  <img src="img/332.png" alt="img" style="zoom: 25%;" />

- 即生成目标句子单词的过程成了下面的形式：
  $$
  y_1 = f1(C_1) \\\\
  y_2 = f1(C_2, y_1) \\\\
  y_3 = f1(C_3, y_1, y_2)
  $$

- 而每个Ci可能对应着不同的源语句子单词的注意力分配概率分布，比如对于上面的英汉翻译来说，其对应的信息可能如下:
  $$
  C_{Tom}=g(0.6*f2(Tom), 0.2*f2(Chase), 0.2*f2(Jerry)) \\\\
  C_{Chase}=g(0.2*f2(Tom), 0.7*f2(Chase), 0.1*f2(Jerry)) \\\\
  C_{Jerry}=g(0.3*f2(Tom), 0.2*f2(Chase), 0.5*f2(Jerry))
  $$

- f2函数代表Encoder对输入英文单词的某种变换函数，比如如果Encoder是用的RNN模型的话，这个f2函数的结果往往是某个时刻输入后隐层节点的状态值；g代表Encoder根据单词的中间表示合成整个句子中间语义表示的变换函数，一般的做法中，g函数就是对构成元素加权求和，即下列公式
$$
C_i = \sum_{j=1}^{L_x}a_{ij}h_j
$$

- Lx代表输入句子source的长度, a_ij代表在Target输出第i个单词时source输入句子中的第j个单词的注意力分配系数, 而hj则是source输入句子中第j个单词的语义编码, 假设Ci下标i就是上面例子所说的'汤姆', 那么Lx就是3, h1=f('Tom'), h2=f('Chase'),h3=f('jerry')分别输入句子每个单词的语义编码, 对应的注意力模型权值则分别是0.6, 0.2, 0.2, 所以g函数本质上就是加权求和函数, 如果形象表示的话, 翻译中文单词'汤姆'的时候, 数学公式对应的中间语义表示Ci的形成过程类似下图:

<img src="img/315.png" alt="img" style="zoom: 33%;" />







