## 当天知识点回顾

* 能够理解多任务的执行方式
  * 并行
  * 并发
* 能够知道进程的作用
* 能够使用多进程完成多任务
  * import multiprocessing
* 能够知道如果获取进程编号
  * os.getpid() 表示获取当前进程编号
  * os.getppid() 表示获取当前父进程编号
* 能够写出进程执行带有参数的任务
  * args 表示以元组的方式给执行任务传参
  * kwargs 表示以字典方式给执行任务传参
* 能够说出进程的注意点
  * 进程之间不共享全局变量
  * 主进程会等待所有的子进程执行结束再结束
* 能够知道线程的作用
  * import threading
* 能够使用多线程完成多任务
* 能够写出线程执行带有参数的任务
  * args 表示以元组的方式给执行任务传参
  * kwargs 表示以字典方式给执行任务传参

## 每日练习

### 题目1（简答题）

题干：什么是多任务编程？多任务编程有哪些实现方式？列举一些生活中进行多任务的案例。

##### 考察知识点：

理解多任务编程

##### 参考答案 

```
多任务是指在同一时间内，同时去做多个事情。
在多任务编程时，可以使用进程，线程和协程的方式来实现多任务编程。

生活案例：
一边唱，一边跳
一边吃饭，一边追剧
一边听歌，一边跑步
```

### 题目2（简答题）

题干：简述你对进程的理解

##### 考察知识点：

进程的理解

##### 参考答案 

```
进程是应用程序在操作系统中的一种实例表现，一个应用程序至少会对应一个进程。
进程是系统进行资源分配基本单位，每启动一个进程操作系统都需要为其分配运行资源。
在创建子进程时，子进程会复制当前父进程的执行环境。
线程是依附在进程里面的，没有进程就没有线程，一个进程默认提供一条线程，进程可以创建多个线程
```

### 题目3（简答题）

题干：

1. 单核情况下如果如果有多个程序如何运行? 
2. 多核情况下有多个程序又如何运行? 
3. 多任务方式下，并行和并发有什么区别?
4. 一个进程中的多个线程一定是并发执行的吗?
5. 多个进程一定是并行执行的吗?

##### 考察知识点：

并行和并发区别

##### 参考答案 

```
1. 串行执行，即一个程序执行完时间片之后切换到另一个程序执行
2. 多核情况，多个程序可能被分到不同的 CPU 同时并行执行，也有可能被分配到同一个 CPU 中并发执行
3. 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
   并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。
4. 一个进程中的多个线程一定是并发执行的吗? 不一定，也可能是并行。
5. 多个进程一定是并行执行的吗?不一定，也可能是并发。
```

### 题目4（简答题）

题干：什么是线程？

##### 考察知识点：

对线程的认识

##### 参考答案 

```
线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。
```

### 题目5（实操题）

题干：说一下什么是进程什么是线程以及两者的区别:

##### 考察知识点：

​	线程和进程的区别和联系

##### 参考答案 

```
1.进程是操作系统资源分配的最小单位，线程是CPU调度的最小单位
2.线程依附于进程，没有进程就没有线程，一个进程默认提供一个线程（主线程），进程可以创建多个线程
3.进程不共享全局变量，同一个进程中的线程共享全局变量（资源竞争-->互斥锁，互斥锁可能产生死锁）
4.进程开销大但可以利用多核（并行），线程开销小但不能利用多核（并发）
```

### 题目6（实操题）

题干：

1. 开辟两个子进程
2. 子进程1设置为死循环, 每隔1秒打印一次"进程信息"
3. 子进程2接收一个整数类型参数, 进程2循环的次数即为传入的整形数字, 每隔1秒循环一次
4. 当前的程序什么时候结束？

##### 考察知识点：

1. 创建子进程
2. 为子进程传参
3. 主进程等待子进程结束再结束

##### 参考答案 

```python
import multiprocessing
import time


def func1():
    while True:
        print("func1")
        time.sleep(1)

def func2(n):
    for i in range(n):
        print("func2")
        time.sleep(1)

if __name__ == '__main__':
    p1 = multiprocessing.Process(target=func1)
    p2 = multiprocessing.Process(target=func2, args=(5,))
    p1.start()
    p2.start()
    
    
# 当前的程序不会结束，因为主进程会等待所有的子进程结束之后再结束。进程 1 是死循环,所以程序不会结束.
```





## 拓展提高

### 题目7（实操题）

题干：创建一个子进程，以及一个全局变量。子进程修改全局变量，然后每隔 1 秒打印全局变量的值和当前进程的 PID，执行 10 次后退出；主进程等待子进程运行完成，最后打印出全局变量的值和当前进程的 PID。

​	尝试从运行结果分析出一个结论。

##### 考察知识点：

1. 创建子进程
2. 进程间不共享全局变量

##### 训练提示

1. 创建子进程需要哪个模块?哪个类? 
2. 创建进程时 target 参数、args 参数、kwargs 参数分别是什么含义?
3. 对象创建之后还需要做什么才能启动子进程?
4. 如何获取当前进程的 PID?

##### 参考答案 

```python
import multiprocessing
import time
import os
g_number = 0

def update_number():
    """让子进程运行"""
    print("子进程开始修改变量了")
    global g_number
    g_number += 1
   	for i in range(10):
	    print("子进程修改变量完成%s PID=%s" % (g_number,os.getpid()))
        time.sleep(1)


if __name__ == '__main__':
    # 1 创建一个子进程　运行　update_number
    pro = multiprocessing.Process(target=update_number)
    pro.start()

    # 2 创建一个全局变量
    # 3 让子进程修改全局变量　
    # 4 让主进程等待子进程退出　打印全局变量的值　
    #    如果这个值和初始值一样　　说明进程间不共享全局资源　; 否则共享
    pro.join()
    print("得到最终值为%s PID=%s" % (g_number,os.getpid()))
```

### 题目8（实操题）

题干：使用进程实现文件夹的整体拷贝。在拷贝文件夹的文件时，如果文件夹中的文件很多，那么一个一个拷贝，效率会很低下，那么可以使用多任务的形式来实现文件夹下的文件进行同时拷贝，提高拷贝效率。请写出一个程序实现这个功能！（源目录：/Users/KG/Desktop/test；目标目录：/Users/KG/Desktop/test_copy）

> 备注: 不需要考虑文件夹包含文件夹,假设文件夹中都是普通的文件

##### 考察知识点：

1. os模块
2. 创建多进程实现多任务
3. 文件读写

##### 训练提示

1. 如何用程序实现拷贝？怎么实现？
2. 在进行拷贝时，是否需要判断目标文件夹是否已经存在？怎么判断？
3. 当文件夹不存在时，如何新建？
4. 路径如何拼接？
5. 如何读取文件内容？如何写入文件内容？
6. 如何实现多进程操作？

##### 参考答案 

```python
import multiprocessing
import os


def copy_single_file(src_file, dest_file):
    """复制拷贝单个文件
    :param src_file: 要拷贝的源文件
    :param dest_file: 复制之后的文件
    :return: None
    """
    # 读打开原文件
    f_r = open(src_file, 'rb')
    # 写打开新文件
    f_w = open(dest_file, 'wb')
    # 将原文件中的内容写入到新文件中,防止文件太大,使用循环读取
    while True:
        buf = f_r.read(1024)
        if len(buf) != 0:
            f_w.write(buf)
        else:
            break
    f_r.close()
    f_w.close()
    # 输出拷贝的信息,相当于是 cp的 -v 参数
    print(f"{src_file} -> {dest_file}")


def my_copy(src, dest):
    """ 目录拷贝
    :param src: 要拷贝的目录
    :param dest:  拷贝后的目录名
    :return: None
    """
    # 判断目标目录是否存在,存在直接使用,不存在,创建
    if not os.path.exists(dest):
        os.mkdir(dest)

    # 获取目录中的所有文件
    file_list = os.listdir(src)
    for i in file_list:
        sub_process = multiprocessing.Process(target=copy_single_file, args=(src+'/'+i, dest + "/" + i))
        sub_process.start()


if __name__ == '__main__':
    # src_dir = input('请输入要拷贝的原目录')
    src_dir = "/home/ubuntu/Desktop/tmp"
    if os.path.exists(src_dir):
        dest_dir = src_dir + '_copy'
        my_copy(src_dir, dest_dir)
    else:
        print('输入的目录信息不存在')
```
