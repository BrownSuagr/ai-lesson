## day05问题小结

1.一些分步骤的需求大部分可以独立写出来，但是如果拿到一个总的需求不知道如何分步骤。

这个问题主要原因是对需求不明确，了解不透彻导致的。搞清楚需求同时还要熟练掌握前面pandas处理，这样才能把要做的事情通过代码实现。所以还是要多看多练多思考，把前面pandas基本功能掌握

比如，在处理数据时，是应该删除空字符还是填充空字符? 

从行来看，一般有缺失数据，可以把对应的行删掉；从列来看，如果列缺失太多，则把整个列删掉。这里行对应的就是前面机器学习中样本，列对应的就是特征值的概念。

比如，应不应该转置表格以进行后续的操作？等等。转置不转置没什么区别，就是处理时注意axis就行了

2.图表API学的太差了，就只会用最简单的折线图，柱状图，直方图，稍微复杂点的就不太会了。这样就够了，更复杂的需求要学会看文档和示例。

## 一、AB测试实战

### 学习目标

- 掌握如何设计AB测试
- AB测试效果如何解读
- 掌握如何进行实验设计与效果计算

### 1、AB测试介绍

#### 1.0 简介

AB测试：以“对照”知“优劣”



#### 1.1 AB测试的关键点：目标KPI和策略

目标KPI：指评判AB测试效果优劣的最终指标

策略：AB组分别采取的策略的差异点



#### 1.2 AB测试的作用

实现目标KPI的最大化：通过在小样本用户中进行实验（**避免错误决策影响用户体验**），找到对KPI最优的策略

#### 1.3 AB测试实施的一般步骤



### 2、AB测试常见问题和应对方案

#### 2.1 如何分配流量

一般采用A组B组人数相等的方法进行流量分配

- 利用随机数

- 利用某些随机ID的尾数



#### 2.2 确定试验有效的最小参与人数

帮助计算样本量的网站：https://www.evanmiller.org/ab-testing/sample-size.html

- 上图中 Baseline conversion rate： 这里填写基准比率 10%
- Minimum Detectable Effect：这里填写最低的可探知效果2%
- Significance level α：显著性水平  一般选择5%
- Statistical power 1−β：统计功效（statistical power ）一般选择80%



#### 2.3 AB测试中的假设检验

为什么要计算参与AB测试的最少参与人数？

- 如果抽取的用户数量过少，没有统计学意义
- 如果抽取的用户过多，一旦我们的新方案与预期效果偏差较大则会对用户体验带来较大影响

用假设检验的理论帮助我们计算参与实验的最少人数

**假设检验的基本思想**

- 假设检验的基本思想是“小概率事件”原理，其统计推断方法是带有某种概率性质的**反证法**。

假设检验举例——鉴别可口可乐和百事可乐

如果该同学连喝5杯都做出了正确的判断， 那么我们可以计算得知 0.5^5 = 0.03125 也就是说有 3.125%的可能他是猜对的

**AB测试中的假设检验**

通过上面的例子我们对假设检验有了基本的了解, 接下来我们看一下如何在AB测试中应用假设检验

- 原假设$H_0$​  老的方案老的设计 
- 备择假设$H_1$ 新的方案新的设计



#### 2.4 AB测试与辛普森悖论

AB测试中产生辛普森悖论的原因：流量分割不均匀导致的实验组与对照组的用户特征不一致

B测试中如何避免辛普森悖论

- 要得到科学可信的 AB 测试试验结果，就必须合理的进行正确的流量分割，保证试验组和对照组里的用户特征是一致的，并且都具有代表性，可以代表总体用户特征。

### 3、AB测试代码实战

#### 3.1 项目背景

假设您在一家中型电商公司工作。 UI设计师设计了最新的产品页面想通过页面更新**提高转化率**

- 目前的转化率全年平均在13%左右
- 目标转化率达到 15%。

#### 3.2 设计实验

提出假设

$H_0$ 原假设 老的设计比较好, 新版设计没有用

$H_1$ 备选假设 新的设计比较好



选择变量

- 对照组: 看到旧的设计
- 实验组: 看到新的设计



确定实验人数

```
# 计算effect_size  0.13为当前的转换率  0.15为目标转化率 也就是说我们希望通过新的设计带来2%的提升
effect_size = sms.proportion_effectsize(0.13, 0.15)   

required_n = sms.NormalIndPower().solve_power(
    effect_size, # 传入上面计算的 effect_size
    power=0.8, # 设置 1-β = 80%
    alpha=0.05, # 设置 α 为5%
    ratio=1  # 对照组和测试组人一样, 这里的ratio 比例就是1
    )                                                  
#对结果向上取整
required_n = ceil(required_n)                         

print(required_n)
```



#### 3.3 收集准备数据

- 加载数据到DataFrame
- 检查和清理数据
- 从DataFrame中采样数据每组4720行
  

#### 3.4 分析实验结果

从上面的统计数据来看，旧的和新的落地页表现非常相似，新设计表现略好, 12.3% 与 12.6% 



#### 3.5 假设检验

```
p-value: 0.732
```



#### 3.6 最终结论

最终计算出的p-value = 0.732 远大于我们实验设置的α = 0.05, 我们不能拒绝原假设 旧的主页表现更好, 这就意味着,我们的新页面并不比旧的页面表现好

### 4、小结



## 二、金融风控相关业务介绍

### 1 信贷&风控介绍

信贷业务，就是贷款业务，是商业银行和互联网金融公司最重要的资产业务和主要赢利手段

- 通过放款收回本金和利息，扣除成本后获得利润。
- 贷款平台预测有信贷需求用户的还款情况，然后将本金借贷给还款概率大的用户

信贷领域有两类风险：

- 信用风险：借款人的的还款能力和还款意愿在贷款后出现问题的风险
- 欺诈风险：借款人压根没想还钱，以诈骗为目的

风控业务主要针对这两类风险

- 信用评分系统：针对信用风险

- 反欺诈系统：针对欺诈风险

基于机器学习的人工智能风控模型对比传统人工审批：

- 机器学习效率高，适合金融零售业务



### 2 常见信贷产品及常见风险介绍

信贷产品介绍

现金贷
申请借款->放款给客户->客户还款

消费贷

信用卡，花呗，白条等产品，有账单日，还款日

申请消费贷 -> 额度授信->客户使用消费贷消费

- 产品类型：

  - 单期产品
  - 多期产品

  - 循环额度产品
- 还款方式：

  - 砍头息：短期产品， （服务费）
  - 等额本金
  - 等额本息

常见风险

- 冒名顶替，黑产骗贷
- 多头借贷，借新还旧
- POS机套现，以少换多
- 针对风控模型，制作数据

### 3 风控相关术语介绍

### 4 风控业务案例

1. 加载数据

2. 查看数据基本情况

3. 数据处理，填充缺失值,将日期时间类型转换成datetime类型

4. 为了后续计算，在原始数据基础上构造新的字段：是否逾期，是否逾期90天，未收金额2（校验原始数据中的未收金额），当前逾期天数，历史逾期天数

```python
df2['是否到期'] = df2.apply(lambda x : 0 if x.应付日期 > today_time else 1,axis=1)

df2['是否到期90天'] =  ( today_time - df2.应付日期 ).map(lambda x : 1 if x.days >= 90 else 0)

df2['未收金额2'] =  (df2.账单金额 - df2.实收金额)

df2['历史逾期天数'] = df2.apply(lambda x : (x.实际到账日 -  x.应付日期).days if x.未收金额2 == 0  else  (today_time - x.应付日期).days,axis=1)

df2['当前逾期天数'] = df2.apply(lambda x : (x.历史逾期天数) if x.未收金额2 > 0  else 0 ,axis = 1) 
```

5. 取出指定范围的数据

```python
df3 = df3[(df3['账单季度']<='2018Q4') & (df3['账单季度']>='2017Q3')]
```

6. 按照季度统计账单金额，到期金额，和逾期金额

   1. 按照季度分组，分别统计结果

   2. pyecharts绘图

   3. 账单金额，随着时间越来越多，坏账率控制在1.2%一下

7. 计算每个季度的60天账单入催金额，90天账单入催金额

   1. ```python
      #60天账期的账单金额
      df4 = df3[(df3.账期 == 60)&(df3.是否到期 == 1)]
      fn1 = df4.groupby('账单季度')[['账单金额']].sum()
      fn1.columns = ['60天账期的账单金额']
      #60天账期的入催金额
      df4 = df3[(df3.账期 == 60)&(df3.是否到期 == 1)&(df3.历史逾期天数>0)]
      fn2 = df4.groupby('账单季度')[['未收金额2']].sum()
      fn2.columns = ['60天账期的入催金额']
      ```

   2. ```python
      计算入催率
      dfs = [fn1,fn2,fn3,fn4]
      final2 = pd.concat(dfs,axis=1)
      # final2 = fn1.merge(fn2,on='账单季度').merge(fn3,on='账单季度',how='left').merge(fn4,on='账单季度')
      final2['60天账期入催率'] = round(final2['60天账期的入催金额'] / final2['60天账期的账单金额'],3)
      final2['90天账期入催率'] = round(final2['90天账期的入催金额']/final2['90天账期的账单金额'],3)
      final2
      ```

   3. pyecharts绘图

8. 不同逾期天数的回收情况

   1. ```
      df6 = df3[(df3.未收金额2 == 0)&(df3.是否到期 == 1)].copy()
      #使用cut，讲数据按照逾期天数分箱，然后添加分箱之后结果标签
      df6['历史逾期天数'] = pd.cut(df6['历史逾期天数'],bins=[-999,0,5,10,15,20,30,60,90,999],right=True,
                             labels=['0','1-5','6-10','11-15','16-20','21-30','31-60','61-90','91+'])
      final3 = df6.groupby('历史逾期天数')[['账期']].count()
      final3.columns = ['回收账单数']
      final3
      ```

9. 业务解读

   - 从数据中看出，在2018年Q2季度之前，运营策略比较保守，坏账金额和入催率都比较低，
   - 2018年Q2之后，有可能是由于运营策略调整，给更多的人放贷，但坏账率和入催率均在3%一下，在合理范围内
   - 不同逾期天数收回账单的数据看，30天内能收回绝大部分账单

























